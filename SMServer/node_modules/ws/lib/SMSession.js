/*
Copyright 2012 Microsoft Open Technologies, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

-----------------End of License---------*/


var util = require('util'),
	events = require('events'),
	SMFramer = require('./SMFramer'),
	SMFrameType = require('./SMFrameType'),
	SMStream = require('./SMStream'),
	WebSocket = require('./WebSocket'),
	Error = require('./SMError'),
	SMHeader = require('./SMHeader'),
	ErrorCodes = require('./ErrorCodes');

/**
 * Constants
 */

 // Default protocol version
var version = 1;

/**
 * Speed+Mobility session implementation
 */
function SMSession(address, options) {
	var self = this;
	var _controlFrameHandlers = {};
	var _creditAddition = 1500; //min for adaptor Ethernet
	
	Object.defineProperty(self, '_socket', { writable: false, value: new WebSocket(address, options) });
	Object.defineProperty(self, '_framer', { writable: false, value: new SMFramer() });
	Object.defineProperty(self, '_streams', { writable: false, value: {} });
	Object.defineProperty(self, 'version', { writable: false, value: version });
	Object.defineProperty(self, 'state', { writable: true, value: SMSession.CREATED });
	Object.defineProperty(self, 'request', { writable: false, value: address[0] });
	Object.defineProperty(self, 'options', { writable: false, value: {} });	
	Object.defineProperty(self, 'maxCreditBalance', {writable: false, value: 0xfffffffe});  // infinity
	Object.defineProperty(self, 'flowControl', {writable: true, value: address[0].headers['http2-icb'] < self.maxCreditBalance});
	Object.defineProperty(self, 'creditBalanceFromClient', {writable: true, value: _creditAddition});
	Object.defineProperty(self, 'creditBalanceToClient', {writable: true, value: address[0].headers['http2-icb']});

	self.options.compressionIsStateful = (self.request.headers['x-sm-zlib'] == 'FULL_FLUSH');
	self.options.version = self.request.headers['x-sm-version'];

	function init() {
		self._socket.on('error', handleWebSocketError);
		self._socket.on('open', handleWebSocketOpen);
		self._socket.on('close', handleWebSocketClose);
		self._socket.on('message', handleWebSocketMessage);
		self._socket.on('ping', handleWebSocketPing);
		self._socket.on('pong', handleWebSocketPong);

		_controlFrameHandlers[SMFrameType.RST] = handleRSTFrame;
		_controlFrameHandlers[SMFrameType.SYN_STREAM] = handleSynStreamFrame;		
		_controlFrameHandlers[SMFrameType.SYN_REPLY] = handleSynReplyFrame;	
		_controlFrameHandlers[SMFrameType.HEADERS] = handleHeadersFrame;	
		_controlFrameHandlers[SMFrameType.CREDIT_UPDATE] = handleCreditUpdateFrame;
	}
	
	function prepareDataFrame(streamId, data, flags) {	
		var str, len;	

		if (!(data instanceof Buffer)){
			str = data.toString();
			len = Buffer.byteLength(str, 'utf8');
		} else {
			str = data;
			len = str.length;
		}

		var buffer = new Buffer(len);
		if (str instanceof Buffer)
		{
			str.copy(buffer, 0, 0, len);
		} else {
			buffer.write(str, 0, len);			
		}
		data = buffer;
		
		
		return {
			control: 0,
			streamId: streamId,
			flags: flags || 0,
			data: data || [],
			length: data.length,
			fin: flags & self.FLAG_FIN
		}		
	}

	function prepareControlFrame(streamId, headers, priority, flags) {
		return {
			control: 1,
			streamId: streamId,
			flags: flags || 0,
			headers: headers || {},
			priority: priority || 0,
			version: self.version,
			fin: flags & SMFramer.FLAG_FIN
		}
	}

	function serializeAndSend(frame) {
		var data = self._framer.serialize(frame, self.options);
		self._socket.send(data, {binary:true, fin:frame.fin});
		if (frame.fin) {
			var stream = self._streams[frame.streamId];
			if (stream.state != SMStream.CLOSED)
				stream.state = SMStream.HALF_CLOSED;
		}
	}
	
	function sendRST(streamId, reason) {
		var frame = prepareControlFrame(streamId);
		frame.statusCode = reason;
		frame.type = SMFrameType.RST;
		serializeAndSend(frame);
	}

	function sendCreditUpdate(streamId, creditAddition) {
		var frame = prepareControlFrame(streamId, null, SMFramer.FLAG_FIN);
		frame.creditAddition = creditAddition;
		frame.type = SMFrameType.CREDIT_UPDATE;
		serializeAndSend(frame);
		self.creditBalanceFromClient += creditAddition;
	}

	function sendSynReply(streamId, headers, fin) {
		var frame = prepareControlFrame(streamId, headers, 2, fin ? SMFramer.FLAG_FIN : 0);
		frame.type = SMFrameType.SYN_REPLY;
		serializeAndSend(frame);
	}

	function sendSynStream(streamId, headers, fin) {
		var frame = prepareControlFrame(streamId, headers, 1, fin ? SMFramer.FLAG_FIN : 0);
		frame.type = SMFrameType.SYN_STREAM;
		serializeAndSend(frame);
	}

	function sendHeaders(streamId, headers, fin) {
		var frame = prepareControlFrame(streamId, headers, 3, fin ? SMFramer.FLAG_FIN : 0);
		frame.type = SMFrameType.HEADERS;
		serializeAndSend(frame);
	}

	function sendData(streamId, data, fin) {
		var frame = prepareDataFrame(streamId, data, fin ? 0x01 : 0);

		if (self.flowControl) {
			if (self.creditBalanceToClient > 0) {
				self.creditBalanceToClient -= data.length;
				serializeAndSend(frame);
				console.log('credit balance = ' + (self.creditBalanceToClient));
				
				if (self.creditBalanceToClient > 0) {
					self.emit('sendNext');
				}
			}
		} else {
			serializeAndSend(frame);
		}
	}

	function handleWebSocketError() {
		this.emit.apply(this, arguments);
	}

	function handleWebSocketOpen() {
		self.state = SMSession.OPENED;
		self.emit.apply(this, arguments);
	}

	function handleWebSocketClose(code, message) {	
		self.terminate(code);
		if (self.state != SMSession.CLOSED){
			self.state = SMSession.CLOSED;
			self.emit('close', code, ErrorCodes[code]+ ' ' + message);
		}
	}

	function handleWebSocketPing() {
		self.emit.apply(this, arguments);
	}

	function handleWebSocketPong() {
		self.emit.apply(this, arguments);
	}

	function closeStream(stream) {
		if (stream.state != SMStream.CLOSED) {
			stream.state = SMStream.CLOSED;
			self._streams[stream.streamId] = null;
			self.emit('streamClosed', stream);
		}
	}
	
	function handleFrameError(frame, statusCode) {
		if (frame.streamId) {
			sendRST(frame.streamId, statusCode);
			if (self._streams[frame.streamId]){
				closeStream(self._streams[frame.streamId]);	
			}
			self.emit('error', {streamId:frame.streamId, statusCode:statusCode});
		} else {
			self.emit('error', {statusCode:statusCode});
			self.terminate(statusCode);
		}
	}
	
	function handleFinFrame(frame, stream) {
		if (frame.fin && stream.state == SMStream.HALF_CLOSED){ closeStream(stream);}
	}
	
	function handleSynStreamFrame(frame) {
		function isFrameValid(frame) {
			return (!self._streams[frame.streamId]) && (frame.streamId % 2 == 1);
		}
		if (!isFrameValid(frame)) {
			handleFrameError(frame, Error.PROTOCOL_ERROR)
		} else {
			var stream = new SMStream(frame.streamId, self, frame.headers, frame.flags);
			stream.on('close', function() {  closeStream(stream); } );
			stream.on('send', function(data, fin) { sendData(stream.streamId, data, fin); fin && closeStream(stream); } );
			stream.on('sendHeaders', function(headers, fin) { sendHeaders(stream.streamId, headers, fin); fin && closeStream(stream); } );
			stream.on('error', function(e) { sendRST(stream.streamId, e.statusCode); closeStream(stream); } );
			self._streams[frame.streamId] = stream;
			
			var headers = [];
			headers[SMHeader.Status] = 200;
			headers[SMHeader.Version] = 'HTTP/1.1';
			
			sendSynReply(stream.streamId, {});
			self.emit('streamOpened', stream);
		}
	}

	function handleSynReplyFrame(frame) {
		var steam = self._streams[frame.streamId];
		if (steam) {
			stream.state = SMStream.ACCEPTED;
			self.emit('streamAccepted', stream, frame.headers);
			handleFinFrame(frame, stream);
		} else {
			handleFrameError(frame, Error.INVALID_STREAM);
		}
	}
	
	function validateAndGetStream(frame) {
		var stream = self._streams[frame.streamId];
		if (stream) { 
			if (stream.state != SMStream.CLOSED)
				return stream;
			else 
				handleFrameError(frame, Error.STREAM_ALREADY_CLOSED);	
		}
		else handleFrameError(frame, Error.INVALID_STREAM);		
	}

	function handleCreditUpdateFrame(frame) {
		if (self.flowControl) {
			self.creditBalanceToClient += parseInt(frame.creditAddition);
			console.log("credit balance = " + self.creditBalanceToClient);
			if (self.creditBalanceToClient >= 0xfffffffe)
				sendRST(frame.streamId, Error.FLOW_CONTROL_ERROR);

			if (self.creditBalanceToClient > 0)
				self.emit('sendNext');
		}
		else {
			sendRST(frame.streamId, Error.FLOW_CONTROL_ERROR);
		}
	}
	
	function handleRSTFrame(frame) {
		// we should not send error to client if stream is invalid
		// otherwise RST frames loop can occur
		var stream = self._streams[frame.streamId];
		if (stream) closeStream(stream);
	}

	function handleHeadersFrame(frame) {
		var stream = validateAndGetStream(frame); 
		if (stream) {
			self.emit('headers', stream, frame.headers);
				handleFinFrame(frame, stream);
		}
	}

	function handleDataFrame(frame) { 
		var stream = validateAndGetStream(frame);
		if (self.flowControl) {
			self.creditBalanceFromClient -= frame.data.length;
			if (self.creditBalanceFromClient <= 0) {
				sendCreditUpdate(frame.streamId, (-1 * self.creditBalanceFromClient / _creditAddition + 1) * _creditAddition);
			} else {
				sendCreditUpdate(_creditAddition);
			}
		}
		if (stream) { 
			self.emit('data', stream, frame.data); 
			handleFinFrame(frame, stream);
		}
	}

	function processFrame(frame) {
		if (frame.control) {
			_controlFrameHandlers[frame.type](frame);
		} else {
			handleDataFrame(frame);
		}
	}

	function handleWebSocketMessage(data) {
		try {
			self.emit.apply(this, arguments);
			var frame = self._framer.deserialize(data, self.options);
			processFrame(frame);
		} catch (error) {
			self.emit('error', {statusCode:Error.INTERNAL_ERROR, error:error});
			self.terminate(Error.INTERNAL_ERROR);
		}
	}

	init();
}

/**
 * Inherits from EventEmitter.
 */
util.inherits(SMSession, events.EventEmitter);

SMSession.prototype.ping = function(data, options, dontFailWhenClosed) {
	this._socket.ping(data, options, dontFailWhenClosed);
}

SMSession.prototype.pong = function(data, options, dontFailWhenClosed) {
	this._socket.pong(data, options, dontFailWhenClosed);
}

SMSession.prototype.resume = function() {
	this._socket.resume();
}

SMSession.prototype.pause = function() {
	this._socket.pause();
}

SMSession.prototype.stream = function(options, cb) {
	this._socket.stream(options, cb);
}

/**
 * Terminates current session
 * @api public
 */
SMSession.prototype.terminate = function(code) {
	if (this._socket 
		&& (this._socket.readyState == WebSocket.OPEN || this._socket.readyState == WebSocket.CONNECTING))
		this._socket.close( code || Error.NORMAL);
}

module.exports = SMSession;

/**
 * Session States
 */
(function() {
  var SessionState = {
      CREATED: 0
	, OPENED: 1
    , CLOSED: 2
  };

  for (var state in SessionState) {
    if (!SessionState.hasOwnProperty(state)) continue;
    Object.defineProperty(SMSession, state, { enumerable: true, value: SessionState[state]});
  }
})();
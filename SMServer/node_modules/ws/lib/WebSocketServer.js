/*----------ws License and Copyright Notices--------
ws
http://einaros.github.com/ws
-----------------------------------
This file is based on or incorporates material from the projects listed below 
(collectively, “Third Party Code”). Microsoft is not the original author 
of the Third Party Code.   
The original copyright notice and the MIT license, under which Microsoft received 
such Third Party Code, are set forth below.  
Such licenses and notices are provided for informational purposes only.  Microsoft, 
not the third party, licenses the Third Party Code to you under the terms 
of the Microsoft Reference Source Code License set forth below. 
Microsoft reserves all other rights not expressly granted under this agreement, 
whether by implication, estoppel or otherwise.  
----------------------------------------
ws: a node.js websocket client
Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>
http://einaros.github.com/ws

Portions Copyright Microsoft Open Technologies, Inc.

---------------------------------------
Copyright 2012 Microsoft Open Technologies, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

---------------------------------

Provided for Informational Purposes Only
MIT License

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

--End of ws Licenses and Copyright Notices------*/

var util = require('util')
  , events = require('events')
  , http = require('http')
  , https = require('https')
  , crypto = require('crypto')
  , url = require('url')
  , Options = require('options')
  , WebSocket = require('./WebSocket')
  , tls = require('tls')
  , url = require('url')
  , SMSession = require('./SMSession');
/**
 * WebSocket implementation
 */
function WebSocketServer(options, callback) {
  options = new Options({
    host: '127.0.0.1',
    port: null,
    server: null,
    verifyClient: null,
    path: null,
    noServer: false,
    disableHixie: false,
    clientTracking: true
  }).merge(options);
  if (!options.value.port && !options.value.server && !options.value.noServer) {
    throw new TypeError('`port` or a `server` must be provided');
  }

  var self = this;

  if (options.value.port) {
    Object.defineProperty(this, '_server', {
      configurable: true,
       value: http.createServer(function (req, res) {
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end('Hello Speed+Mobility Server! Please use SM client to connect.');
      })
    });

    this._server.listen(options.value.port, options.value.host || '127.0.0.1', callback);
    Object.defineProperty(this, '_closeServer', {
      value: function() { self._server.close(); }
    });
  }
  else if (options.value.server) {
    Object.defineProperty(this, '_server', { value: options.value.server, configurable: true });
    if (options.value.path) {
      // take note of the path, to avoid collisions when multiple websocket servers are
      // listening on the same http server
      if (this._server._webSocketPaths && options.value.server._webSocketPaths[options.value.path]) {
        throw new Error('two instances of WebSocketServer cannot listen on the same http server path');
      }
      if (typeof this._server._webSocketPaths !== 'object') {
        Object.defineProperty(this._server, '_webSocketPaths', { value: {}, configurable: true });
      }
      this._server._webSocketPaths[options.value.path] = 1;
    }
  }


  if (typeof this._server != 'undefined') {
    this._server.on('error', function(error) {
      self.emit('error', error)
    });
    this._server.on('upgrade', function(req, socket, upgradeHead) {
      self.handleUpgrade(req, socket, upgradeHead, function(client) {
        self.emit('connection', client);
      });
    });
  }

  Object.defineProperty(this, 'options', { value: options.value });
  Object.defineProperty(this, 'path', { value: options.value.path });
  Object.defineProperty(this, '_clients', { value: [] });
  Object.defineProperty(this, 'clients', {
    get: function() { return self._clients; }
  });
}

/**
 * Inherits from EventEmitter.
 */

util.inherits(WebSocketServer, events.EventEmitter);

/**
 * Immediately shuts down the connection.
 *
 * @api public
 */

WebSocketServer.prototype.close = function(code, data) {
  // terminate all associated clients
  var error = null;
  try {
    for (var i = 0, l = this._clients.length; i < l; ++i) {
      this._clients[i].terminate();
    }
  }
  catch (e) {
    error = e;
  }

  // remove path descriptor, if any
  if (this.path && this._server._webSocketPaths) {
    delete this._server._webSocketPaths[this.path];
    if (Object.keys(this._server._webSocketPaths).length == 0) {
      delete this._server._webSocketPaths;
    }
  }

  // close the http server if it was internally created
  try {
    if (typeof this._closeServer !== 'undefined') {
      this._closeServer();
    }
  }
  finally {
    delete this._server;
  }
  if (error) throw error;
}

/**
 * Handle a HTTP Upgrade request.
 *
 * @api public
 */

WebSocketServer.prototype.handleUpgrade = function(req, socket, upgradeHead, cb) {
  // check for wrong path
  if (this.options.path) {
    var u = url.parse(req.url);
    if (u && u.pathname !== this.options.path) return;
  }

  if (typeof req.headers.upgrade != 'undefined' && req.headers.upgrade.toLowerCase() == 'http/2.0') {
    console.log('Websocket upgrade canceled');
    return;
  }
  
  if (typeof req.headers.upgrade === 'undefined' || req.headers.upgrade.toLowerCase() !== 'websocket') {
    abortConnection(socket, 400, 'Bad Request');
    return;
  }

  if (req.headers['sec-websocket-key1']) handleHixieUpgrade.apply(this, arguments);
  else handleHybiUpgrade.apply(this, arguments);
}

module.exports = WebSocketServer;

/**
 * Entirely private apis,
 * which may or may not be bound to a sepcific WebSocket instance.
 */

function handleHybiUpgrade(req, socket, upgradeHead, cb) {
  // verify Sec-WebSocket-Extensions
  if (!req.headers['sec-websocket-extensions']) {
    abortConnection(socket, 400, 'Bad Request');
    return;
  }

  //verify connection
  if (!req.headers['connection'] || req.headers['connection'] != 'Upgrade, http2-icb') {
    abortConnection(socket, 400, 'Bad Request');
    return;
  }

  // verify key presence
  if (!req.headers['sec-websocket-key']) {
    abortConnection(socket, 400, 'Bad Request');
    return;
  }

  // verify version
  var version = parseInt(req.headers['sec-websocket-version']);
  if ([8, 13].indexOf(version) === -1) {
    abortConnection(socket, 400, 'Bad Request');
    return;
  }

  // verify client
  var origin = version < 13 ?
    req.headers['sec-websocket-origin'] :
    req.headers['origin'];

  var args = [req, socket, upgradeHead, version, cb];
  if (typeof this.options.verifyClient == 'function') {
    var info = {
      origin: origin,
      secure: typeof req.connection.encrypted !== 'undefined',
      req: req
    };
    if (this.options.verifyClient.length == 2) {
      var self = this;
      this.options.verifyClient(info, function(result) {
        if (!result) abortConnection(socket, 401, 'Unauthorized')
        else completeUpgrade.apply(self, args);
      });
      return;
    }
    else if (!this.options.verifyClient(info)) {
      abortConnection(socket, 401, 'Unauthorized');
      return;
    }
  }

  completeUpgrade.apply(this, args);
}

function completeUpgrade(req, socket, upgradeHead, version, cb) {
   var protocol = req.headers['sec-websocket-protocol'];

  // calc key
  var key = req.headers['sec-websocket-key'];
  var shasum = crypto.createHash('sha1');
  shasum.update(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
  key = shasum.digest('base64');

  var headers = [
      'HTTP/1.1 101 Switching Protocols'
    , 'Upgrade: websocket'
    , 'Connection: Upgrade, http2-icb'
    , 'Sec-WebSocket-Accept: ' + key
    , 'Sec-WebSocket-Extensions: http2'
  ];
  if (typeof protocol != 'undefined') {
    headers['Sec-WebSocket-Protocol'] = protocol;
  }
  try {
    socket.write(headers.concat('', '').join('\r\n'));
  }
  catch (e) {
    try { socket.end(); } catch (_) {}
    return;
  }
  socket.setTimeout(0);
  socket.setNoDelay(true);
  var client = new SMSession([req, socket, upgradeHead], {
    protocolVersion: version,
    protocol: protocol
  });

  if (this.options.clientTracking) {
    this._clients.push(client);
    var self = this;
    client.on('close', function() {
      var index = self._clients.indexOf(client);
      if (index != -1) {
        self._clients.splice(index, 1);
      }
    });
  }
  cb(client);
}

function handleHixieUpgrade(req, socket, upgradeHead, cb) {
  if (this.options.disableHixie) {
    abortConnection(socket, 401, 'Hixie support disabled');
    return;
  }

  // verify key presence
  if (!req.headers['sec-websocket-key2']) {
    abortConnection(socket, 400, 'Bad Request');
    return;
  }

  // setup handshake completion to run after client has been verified
    var self = this;
  var onClientVerified = function() {
    var protocol = req.headers['sec-websocket-protocol'];

    // handshake completion code to run once nonce has been successfully retrieved
    var completeHandshake = function(nonce, rest) {
      // calculate key
      var k1 = req.headers['sec-websocket-key1']
        , k2 = req.headers['sec-websocket-key2']
        , md5 = crypto.createHash('md5');
      [k1, k2].forEach(function (k) {
        var n = parseInt(k.replace(/[^\d]/g, ''))
          , spaces = k.replace(/[^ ]/g, '').length;
        if (spaces === 0 || n % spaces !== 0){
          abortConnection(socket, 400, 'Bad Request');
          return;
        }
        n /= spaces;
        md5.update(String.fromCharCode(
        n >> 24 & 0xFF,
        n >> 16 & 0xFF,
        n >> 8  & 0xFF,
        n       & 0xFF));
      });
      md5.update(nonce.toString('binary'));

      var headers = [
          'HTTP/1.1 101 Switching Protocols'
        , 'Upgrade: WebSocket'
        , 'Connection: Upgrade, http2-icb'
        , 'Sec-WebSocket-Location: ' + location
        , 'Sec-WebSocket-Extensions: http2'
      ];
      if (typeof protocol != 'undefined') headers.push('Sec-WebSocket-Protocol: ' + protocol);
      if (typeof origin != 'undefined') headers.push('Sec-WebSocket-Origin: ' + origin);

      socket.setTimeout(0);
      socket.setNoDelay(true);
      try {
        socket.write(headers.concat('', '').join('\r\n'));
        socket.write(md5.digest('binary'), 'binary');
      }
      catch (e) {
        try { socket.end(); } catch (_) {}
        return;
      }

      var client = new WebSocket([req, socket, rest], {
        protocolVersion: 'hixie-76',
        protocol: protocol
      });
      if (this.options.clientTracking) {
        self._clients.push(client);
        client.on('close', function() {
          var index = self._clients.indexOf(client);
          if (index != -1) {
            self._clients.splice(index, 1);
          }
        });
      }
      cb(client);
    }

    // retrieve nonce
    var nonceLength = 8;
    if (upgradeHead && upgradeHead.length >= nonceLength) {
      var nonce = upgradeHead.slice(0, nonceLength);
      var rest = upgradeHead.length > nonceLength ? upgradeHead.slice(nonceLength) : null;
      completeHandshake.call(self, nonce, rest);
    }
    else {
      // nonce not present in upgradeHead, so we must wait for enough data
      // data to arrive before continuing
      var nonce = new Buffer(nonceLength);
      upgradeHead.copy(nonce, 0);
      var received = upgradeHead.length;
      var rest = null;
      var handler = function (data) {
        var toRead = Math.min(data.length, nonceLength - received);
        if (toRead === 0) return;
        data.copy(nonce, received, 0, toRead);
        received += toRead;
        if (received == nonceLength) {
          socket.removeListener('data', handler);
          if (toRead < data.length) rest = data.slice(toRead);
          completeHandshake.call(self, nonce, rest);
        }
      }
      socket.on('data', handler);
    }
  }

  // verify client
  var location = ((req.headers['x-forwarded-proto'] === 'https' || socket.encrypted) ? 'wss' : 'ws') + '://' + req.headers.host + req.url
    , origin = req.headers['origin'];
  if (typeof this.options.verifyClient == 'function') {
    var info = {
      origin: origin,
      secure: typeof req.connection.encrypted !== 'undefined',
      req: req
    };
    if (this.options.verifyClient.length == 2) {
      var self = this;
      this.options.verifyClient(info, function(result) {
        if (!result) abortConnection(socket, 401, 'Unauthorized')
        else onClientVerified.apply(self);
      });
      return;
    }
    else if (!this.options.verifyClient(info)) {
      abortConnection(socket, 401, 'Unauthorized');
      return;
    }
  }
  onClientVerified();
}

function abortConnection(socket, code, name) {
  try {
    var response = [
      'HTTP/1.1 ' + code + ' ' + name,
      'Content-type: text/html'
    ];
    socket.write(response.concat('', '').join('\r\n'));
    socket.end();
	console.log('Connection aborted!');
  }
  catch (e) {}
}
